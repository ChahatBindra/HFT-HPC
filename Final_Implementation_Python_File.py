# -*- coding: utf-8 -*-
"""HPC_6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AERM6DjO4Y1xDNFmVX9AoO-RYiwg0cQE
"""

import tensorflow as tf

tf.__version__

from tensorflow.python.client import device_lib
print(device_lib.list_local_devices())

print("Num GPUs Available: ", len(tf.config.experimental.list_physical_devices('GPU')))

print("Num GPUs Available: ", len(tf.config.experimental.list_physical_devices()))

from google.colab import drive
drive.mount('/content/drive')

from tensorflow.python.keras import backend as K

# adjust values to your needs
config = tf.compat.v1.ConfigProto( device_count = {'GPU': 2 , 'CPU': 8} )
sess = tf.compat.v1.Session(config=config) 
K.set_session(sess)

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import math
import nltk

from nltk.stem import WordNetLemmatizer 
from nltk.stem.lancaster import LancasterStemmer
from nltk.stem import PorterStemmer
from nltk.corpus import stopwords
from nltk import word_tokenize

from sklearn.naive_bayes import MultinomialNB, GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.preprocessing import LabelEncoder
from scipy.sparse import hstack as sp_hstack, vstack as sp_vstack
from scipy.interpolate import make_interp_spline, BSpline
from sklearn.linear_model import LinearRegression

from joblib import Parallel, delayed

import time

from keras.models import Sequential
from keras.layers.recurrent import LSTM, GRU
from keras.layers.core import Dense, Activation, Dropout
from keras.layers.embeddings import Embedding
from keras.layers.normalization import BatchNormalization
from keras.utils import np_utils
from keras.layers import GlobalMaxPooling1D, Conv1D, MaxPooling1D, Flatten, Bidirectional, SpatialDropout1D
from keras.preprocessing import sequence, text
from keras.callbacks import EarlyStopping, Callback

import pickle
import matplotlib.pyplot as plt
# %matplotlib inline

dataset_train = pd.read_csv('/content/drive/MyDrive/HPC/NSE-TATAGLOBAL.csv')
training_set = dataset_train.iloc[:, 1:2].values

dataset_train.head()

training_set

training_set.shape

training_set =  pd.DataFrame(training_set)

training_set.head()

# Feature Scaling
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler(feature_range = (0, 1))
training_set_scaled = sc.fit_transform(training_set)

# Creating a data structure with 60 timesteps and 1 output
X_train = []
y_train = []
for i in range(60, 2035):
    X_train.append(training_set_scaled[i-60:i, 0])
    y_train.append(training_set_scaled[i, 0])
X_train, y_train = np.array(X_train), np.array(y_train)

X_train = pd.DataFrame(X_train)
y_train = pd.DataFrame(y_train)

y_train.head()

X_train.head()

# Part 3 - Making the predictions and visualising the results

# Getting the real stock price of 2017
dataset_test = pd.read_csv('/content/drive/MyDrive/HPC/tatatest.csv')
real_stock_price = dataset_test.iloc[:, 1:2].values

# Getting the predicted stock price of 2017
dataset_total = pd.concat((dataset_train['Open'], dataset_test['Open']), axis = 0)
inputs = dataset_total[len(dataset_total) - len(dataset_test) - 60:].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)
X_test = []
for i in range(60, 76):
    X_test.append(inputs[i-60:i, 0])
X_test = np.array(X_test)
# X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

real_stock_price = sc.fit_transform(real_stock_price)

X_test = pd.DataFrame(X_test)

X_test.head()

y_test =  pd.DataFrame(real_stock_price)

reg = LinearRegression()

reg.fit(X_train, y_train)

reg.score(X_train, y_train)

import numpy as np
from sklearn import linear_model
from sklearn import svm

SGD_Regressor = linear_model.SGDRegressor()
SGD_Regressor.fit(X_train, y_train)

SGD_Regressor.score(X_train, y_train)

Bayesian_Ridge = linear_model.BayesianRidge()
Bayesian_Ridge.fit(X_train, y_train)

Bayesian_Ridge.score(X_train, y_train)

Lasso_Lars = linear_model.LassoLars()
Lasso_Lars.fit(X_train, y_train)

Lasso_Lars.score(X_train, y_train)

ARD_Regression = linear_model.ARDRegression()
ARD_Regression.fit(X_train, y_train)

ARD_Regression.score(X_train, y_train)

TheilSen_Regressor = linear_model.TheilSenRegressor()
TheilSen_Regressor.fit(X_train, y_train)

TheilSen_Regressor.score(X_train, y_train)

y_test.head()

# y_test

models = [reg, SGD_Regressor, Bayesian_Ridge,Lasso_Lars, ARD_Regression, TheilSen_Regressor]

def fit_and_evaluate_model(model, x_train, y_train, x_val, y_val):
    model.fit(x_train, y_train)
    probs = model.predict(x_val)
    score = model.score(x_val, y_val)
    return probs, score

start_ensemble = time.time()
results = []
for model in models:
    results.append(fit_and_evaluate_model(model, X_train, y_train, X_test, y_test))
end_ensemble = time.time()
time_ensemble_seq = end_ensemble - start_ensemble
print('Time taken by sequential run of ensemble model: {} seconds'.format(time_ensemble_seq))

models_name = ["Linear-Regression", "SGD-Regressor", "Bayesian-Ridge" , "Lasso-Lars", "ARD-Regression", "TheilSen-Regressor"]

len(results )

import matplotlib.pyplot as plt
ind = 0
for i in results:
  plt.plot(i[0], label = models_name[ind])
  ind = ind+1
plt.title("Series Predictions")
plt.xlabel('Time')
plt.ylabel('Predicted Stock Prices')
plt.legend()
plt.show()



start_ensemble = time.time()
results = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(fit_and_evaluate_model)(model, X_train, y_train, X_test, y_test) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt
ind = 0
for i in results:
  plt.plot(i[0], label = models_name[ind])
  ind = ind+1
plt.title("Parallel Predictions")
plt.xlabel('Time')
plt.ylabel('Predicted Stock Prices')
plt.legend()
plt.show()



start_ensemble = time.time()
results = Parallel(n_jobs=3, backend='multiprocessing', verbose=0)\
                            (delayed(fit_and_evaluate_model)(model, X_train, y_train, X_test, y_test) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt
ind = 0
for i in results:
  plt.plot(i[0], label = models_name[ind])
  ind = ind+1
plt.title("Parallel Predictions Multiprocessing")
plt.xlabel('Time')
plt.ylabel('Predicted Stock Prices')
plt.legend()
plt.show()

start_ensemble = time.time()
results = Parallel(n_jobs=3, backend='threading', verbose=0)\
                            (delayed(fit_and_evaluate_model)(model, X_train, y_train, X_test, y_test) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt
ind = 0
for i in results:
  plt.plot(i[0], label = models_name[ind])
  ind = ind+1
plt.title("Parallel Predictions Threading")
plt.xlabel('Time')
plt.ylabel('Predicted Stock Prices')
plt.legend()
plt.show()



import matplotlib.pyplot as plt

left = ["Linear", "Loky", "Multiprocessing", "Threading"]
height = [56.51558971405029,50.017308473587036, 57.56380796432495,  56.52783823013306]
  
plt.bar( left,height,width = 0.8)
  
plt.xlabel('Models')
# naming the y-axis
plt.ylabel('Time Taken')
# plot title
plt.title('Comparison Chart !')
  
# function to show the plot
plt.show()







models = [reg, SGD_Regressor, Bayesian_Ridge,Lasso_Lars, ARD_Regression, TheilSen_Regressor]

def fit_and_evaluate_model(model, x_train, y_train, x_val, y_val):
    model.fit(x_train, y_train)
    probs = model.predict(x_val)
    score = model.score(x_val, y_val)
    return probs, score


start_ensemble = time.time()
results = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(fit_and_evaluate_model)(model, X_train, y_train, X_test, y_test) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

arr = []
mid = []
for i in results[0][0]:
  mid.append(i[0])
arr.append(mid)

for i in results[1:]:
  mid=[]
  for j in i[0]:
    mid.append(j)
  arr.append(mid)

len(arr)

weights = []
for i in results:
  weights.append(i[1])
weights

y_test_list = list(y_test[0])



def simple_average(real ,weights , arr ):
  final = []
  for i in range(4,len(real)):
    before = real[i-1]
    t,f = 0,0
    for j in arr:
      s=sum(j[i-4:i+1])/5
      if(s>before):
        t=t+1
      else:
        f=f+1
    if(t>f):
      final.append("Buy")
    else:
      final.append("Don't Buy")  
  return(final)

# start_ensemble = time.time()
simple_average(y_test_list, weights, arr)
# end_ensemble = time.time()
# time_ensemble_par = end_ensemble - start_ensemble
# time_ensemble_par

!pip install pymp-pypi

import pymp

def simple_average_parallel(real ,weights , arr ):
  final = []
  with pymp.Parallel(2) as p:
      for i in p.xrange(4,len(real)+1):
        before = real[i-1]
        t,f = 0,0
        for j in arr:
          with p.lock:
            s=sum(j[i-4:i+1])/5
            if(s>before):
              t=t+1
            else:
              f=f+1
        if(t>f):
          final.append("Buy")
        else:
          final.append("Don't Buy")  
  return(final)

# start_ensemble = time.time()
simple_average_parallel(y_test_list, weights, arr)
# end_ensemble = time.time()
# time_ensemble_par = end_ensemble - start_ensemble
# time_ensemble_par

def weighted_average(real ,weights , arr ):
  final = []
  copy = [0]*len(weights)

  # Calculating Weights
  for i in range(len(weights)) :
    m = weights.index(min(weights))
    copy[m] = i+1

  for i in range(4,len(real)):
    before = real[i-1]
    t,f,ind = 0,0,0

    for j in arr:
      s=sum(j[i-4:i+1])/5
      if(s>before):
        t=t+(1*copy[ind])
      else:
        f=f+(1*copy[ind])
      ind = ind + 1
    if(t>f):
      final.append("Buy")
    else:
      final.append("Don't Buy")  
  return(final)

weighted_average(y_test_list, weights, arr)

def weighted_average_parallel(real ,weights , arr ):
  final = []
  copy = [0]*len(weights)

  # Calculating Weights
  
  for i in range(len(weights)) :
    m = weights.index(min(weights))
    copy[m] = i+1

  with pymp.Parallel(2) as p:
    for i in range(4,len(real)):
      before = real[i-1]
      t,f,ind = 0,0,0

      for j in arr:
        with p.lock:
          s=sum(j[i-4:i+1])/5
          if(s>before):
            t=t+(1*copy[ind])
          else:
            f=f+(1*copy[ind])
          ind = ind + 1
      if(t>f):
        final.append("Buy")
      else:
        final.append("Don't Buy")  
  return(final)

weighted_average_parallel(y_test_list, weights, arr)

def exponential_average(real ,weights , arr ):
  final = []
  copy = [0]*len(weights)

  # Calculating Weights
  for i in range(len(weights)) :
    m = weights.index(min(weights))
    copy[m] = i+1

  for i in range(4,len(real)):
    before = real[i-1]
    t,f,ind = 0,0,0
    for j in arr:
      s=0
      exp = [0.1,0.2,0.3,0.4,0.5]
      ide = 0
      for k in j[i-4:i+1] :
        s=s + k*(exp[ide])
        ide = ide+1
      s=s/1.5
      if(s>before):
        t=t+(1*copy[ind])
      else:
        f=f+(1*copy[ind])
      ind = ind + 1
    if(t>f):
      final.append("Buy")
    else:
      final.append("Don't Buy")  
  return(final)

exponential_average(y_test_list, weights, arr)

def exponential_average_parallel(real ,weights , arr ):
  final = []
  copy = [0]*len(weights)

  # Calculating Weights
  for i in range(len(weights)) :
    m = weights.index(min(weights))
    copy[m] = i+1
  with pymp.Parallel(2) as p:
    for i in range(4,len(real)):
      before = real[i-1]
      t,f,ind = 0,0,0
      for j in arr:
        with p.lock:
          s=0
          exp = [0.1,0.2,0.3,0.4,0.5]
          ide = 0
          for k in j[i-4:i+1] :
            s=s + k*(exp[ide])
            ide = ide+1
          s=s/1.5
          if(s>before):
            t=t+(1*copy[ind])
          else:
            f=f+(1*copy[ind])
          ind = ind + 1
      if(t>f):
        final.append("Buy")
      else:
        final.append("Don't Buy")  
  return(final)

exponential_average_parallel(y_test_list, weights, arr)

"""# Serial Functions """

#Serial_Implementation-Serial_Functions

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = []
for model in models:
    results_buy.append(model(y_test_list, weights, arr))
end_ensemble = time.time()
time_ensemble_seq = end_ensemble - start_ensemble
print('Time taken by sequential run of ensemble model: {} seconds'.format(time_ensemble_seq))

#Parallel_Implementation_Loky-Serial_Functions

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

#Parallel_Implementation_Multi-Serial_Functions

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='multiprocessing', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

#Parallel_Implementation_Threading-Serial_Functions

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='threading', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt

left = ["Linear", "Loky", "Multiprocessing", "Threading"]
height = [0.009655475616455078, 0.4409363269805908, 0.2941441535949707, 0.10568904876708984]
  
plt.bar( left,height,width = 0.8)
  
plt.xlabel('Prediction Models')
# naming the y-axis
plt.ylabel('Time Taken')
# plot title
plt.title('Comparison Chart !')
  
# function to show the plot
plt.show()



"""# Serial Functions with Extended Data"""

y_test_list = y_test_list*10

for i in range(len(arr)):
  arr[i] = arr[i]*10

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = []
for model in models:
    results_buy.append(model(y_test_list, weights, arr))
end_ensemble = time.time()
time_ensemble_seq = end_ensemble - start_ensemble
print('Time taken by sequential run of ensemble model: {} seconds'.format(time_ensemble_seq))

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='multiprocessing', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

models = [simple_average, weighted_average, exponential_average]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='threading', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt

left = ["Linear", "Loky", "Multiprocessing", "Threading"]
height = [4.837552309036255, 9.369730472564697, 5.101279258728027,  4.797720909118652]
  
plt.bar( left,height,width = 0.8)
  
plt.xlabel('Prediction Models')
# naming the y-axis
plt.ylabel('Time Taken')
# plot title
plt.title('Comparison Chart !')
  
# function to show the plot
plt.show()



"""# Parallel Functions"""

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = []
for model in models:
    results_buy.append(model(y_test_list, weights, arr))
end_ensemble = time.time()
time_ensemble_seq = end_ensemble - start_ensemble
print('Time taken by sequential run of ensemble model: {} seconds'.format(time_ensemble_seq))

#Parallel_Implementation_Loky-Parallel_Functions

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

#Parallel_Implementation_Multi-Parallel_Functions

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='multiprocessing', verbose=0)\
                            (delayed(model)(y_test_list, weights, arr) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt

left = ["Linear", "Loky", "Multiprocessing"]
height = [0.34371018409729004,  0.7457356452941895  , 0.5589661598205566]
  
plt.bar( left,height,width = 0.8)
  
plt.xlabel('Prediction Models For Parallel Functions')
# naming the y-axis
plt.ylabel('Time Taken')
# plot title
plt.title('Comparison Chart !')
  
# function to show the plot
plt.show()

"""# Parallel Functions with extended data"""



arr_copy = arr
y_test_list_copy = y_test_list

y_test_list_copy = y_test_list_copy*10

for i in range(len(arr_copy)):
  arr_copy[i] = arr_copy[i]*10

#Serial_Implementation-Parallel_Functions

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = []
for model in models:
    results_buy.append(model(y_test_list_copy, weights, arr_copy))
end_ensemble = time.time()
time_ensemble_seq = end_ensemble - start_ensemble
print('Time taken by sequential run of ensemble model: {} seconds'.format(time_ensemble_seq))

#Parallel_Implementation_Loky-Parallel_Functions

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='loky', verbose=0)\
                            (delayed(model)(y_test_list_copy, weights, arr_copy) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

#Parallel_Implementation_Multi-Parallel_Functions

models = [simple_average_parallel, weighted_average_parallel, exponential_average_parallel]

start_ensemble = time.time()
results_buy = Parallel(n_jobs=3, backend='multiprocessing', verbose=0)\
                            (delayed(model)(y_test_list_copy, weights, arr_copy) \
                             for model in models)
end_ensemble = time.time()
time_ensemble_par = end_ensemble - start_ensemble
print('Time taken by parallel run of ensemble model: {} seconds'.format(time_ensemble_par))

import matplotlib.pyplot as plt

left = ["Linear", "Loky", "Multiprocessing"]
height = [14.77927851676941, 8.956387519836426 , 13.621339082717896]
  
plt.bar( left,height,width = 0.8)
  
plt.xlabel('Prediction Models For Parallel Functions')
# naming the y-axis
plt.ylabel('Time Taken')
# plot title
plt.title('Comparison Chart !')
  
# function to show the plot
plt.show()

